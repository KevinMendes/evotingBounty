/*
 * (c) Original Developers indicated in attribution.txt, 2022. All Rights Reserved.
 */

/* jshint node:true, expr:true */
'use strict';

const { assert, expect } = require('chai');

const mathematical = require('../../src/mathematical');
const CommonTestData = require('./data/common-data');
const secureRandom = require('../../src/securerandom');
const forge = require('node-forge');

const BigInteger = forge.jsbn.BigInteger;

const cryptoPolicy = require('../../src/cryptopolicy');

const BE_DEFINED_STRING = 'be defined';
const BE_SERIALIZED_DESERIALIZED_STRING = 'be serialized and deserialized';

let _mathService;
let _mathRandomGenerator;

let _g;
let _p;
let _q;
let _group;
let _anotherGroup;
let _qrGroup;
let _zp224group;
let _elementValue;
let _element;
let _exponentValue;
let _exponent;
let _elements;
let _exponents;
let _qrGroupLarge;
let _exponent1Large;
let _exponent2Large;
let _multiGroupElements;
let _minCertaintyLevel;
let goodGroup;
let goodElements;
let mixedElements;

function beforeEachHook() {
    _mathService = mathematical.newService();

	_mathRandomGenerator = _mathService.newRandomGenerator();

	const testData = new CommonTestData();

	_p = testData.getP();
	_q = testData.getQ();
	_g = testData.getG();
	_group = testData.getGroup();
	_anotherGroup = testData.getAnotherGroup();
	_qrGroup = testData.getQuadraticResidueGroup();
	_zp224group = testData.getZP224Group();

	_elementValue = testData.getElementValue();
	_element = testData.getElement();

	_exponentValue = testData.getExponentValue();
	_exponent = testData.getExponent();
	_elements = testData.getElements();
	_exponents = testData.getExponents();

	_qrGroupLarge = testData.getLargeQuadraticResidueGroup();

	_exponent1Large = testData.getExponent1Large();
	_exponent2Large = testData.getExponent2Large();

	_multiGroupElements = testData.getMultiGroupElements();

	_minCertaintyLevel = testData.getMinimumCertaintyLevel();

	goodGroup = testData.getGoodGroup();
	goodElements = testData.getGoodElements();
	mixedElements = testData.getMixedElements();
}

describe('The mathematical module should be able to ...', function () {

	beforeEach(function () {
		beforeEachHook();
	});

	describe('create a mathematical service that should be able to ..', function () {
		it('be created from a secure random service object provided as input',
			function () {
				const mathService = mathematical.newService(
					{secureRandomService: secureRandom});
				const mathRandomGenerator = mathService.newRandomGenerator();
				const randomExponent = mathRandomGenerator.nextExponent(_qrGroup);
				assert.exists(randomExponent);
			});

		describe(
			'create a new ZpSubgroup object that should be able to ..', function () {
				it(BE_DEFINED_STRING, function () {
					assert.exists(_group);
					assert.exists(_group.identity);
				});

				it('check group membership', function () {
					let element =
						_mathService.newZpGroupElement(_p, _q, BigInteger.ONE);
					assert.isTrue(_group.isGroupMember(element));

					// Check membership of element with wrong q.
					const q2 = new BigInteger('112944007843677807065178165763399565267246004167393449524514388368435081959222805666880161546539427688' +
						'52388620304543688996670690375848802617770565636934220035460181074215933414893892222509573999689749251846623714789740144613' +
						'30137419866766394544223234252584135185487136206089160891352036120768005158964458002829087968623792299271948865366178526537' +
						'66810135726920623859130573258551323832186365223798454775259914198424552313046978708463448080074029827867790076939780085916' +
						'43424220018477463050859602799224949200090041026877932035345087101216098339022526372168916401025893636528156378692327072727' +
						'872801631041174021390051839');
					const p2 = new BigInteger('225888015687355614130356331526799130534492008334786899049028776736870163918445611333760323093078855377' +
						'04777240609087377993341380751697605235541131273868440070920362148431866829787784445019147999379498503693247429579480289226' +
						'60274839733532789088446468505168270370974272412178321782704072241536010317928916005658175937247584598543897730732357053075' +
						'33620271453841247718261146517102647664372730447596909550519828396849104626093957416926896160148059655735580153879560171832' +
						'86848440036954926101719205598449898400180082053755864070690174202432196678045052744337832802051787273056312757384654145455' +
						'745603262082348042780103679');
					const group2 = _mathService.newZpSubgroup(p2, q2, _g);
					const element2 = _mathService.newZpGroupElement(
						group2.p, group2.q, BigInteger.ONE);
					assert.isTrue(!_group.isGroupMember(element2));

					// Check membership of non-member element.
					element =
						_mathService.newZpGroupElement(_p, _q, new BigInteger('5'));
					assert.isTrue(!_group.isGroupMember(element));
				});

				it('be compared with another ZpSubgroup object', function () {
					const group2 = _mathService.newZpSubgroup(_p, _q, _g);

					const q2 = new BigInteger('112944007843677807065178165763399565267246004167393449524514388368435081959222805666880161546539427688' +
						'52388620304543688996670690375848802617770565636934220035460181074215933414893892222509573999689749251846623714789740144613' +
						'30137419866766394544223234252584135185487136206089160891352036120768005158964458002829087968623792299271948865366178526537' +
						'66810135726920623859130573258551323832186365223798454775259914198424552313046978708463448080074029827867790076939780085916' +
						'43424220018477463050859602799224949200090041026877932035345087101216098339022526372168916401025893636528156378692327072727' +
						'872801631041174021390051839');
					const p2 = new BigInteger('225888015687355614130356331526799130534492008334786899049028776736870163918445611333760323093078855377' +
						'04777240609087377993341380751697605235541131273868440070920362148431866829787784445019147999379498503693247429579480289226' +
						'60274839733532789088446468505168270370974272412178321782704072241536010317928916005658175937247584598543897730732357053075' +
						'33620271453841247718261146517102647664372730447596909550519828396849104626093957416926896160148059655735580153879560171832' +
						'86848440036954926101719205598449898400180082053755864070690174202432196678045052744337832802051787273056312757384654145455' +
						'745603262082348042780103679');
					const group3 = _mathService.newZpSubgroup(p2, q2, _g);

					assert.isTrue(_group.equals(group2));
					assert.isTrue(!_group.equals(group3));
				});

				it(BE_SERIALIZED_DESERIALIZED_STRING, function () {
					const groupJson = _group.toJson();

					const groupFromJson = _mathService.newZpSubgroup(groupJson);

					assert.exists(groupFromJson);
					assert.isTrue(groupFromJson.equals(_group));
				});
			});

		describe(
			'create a new ZpGroupElement object that should be able to ..',
			function () {
				it(BE_DEFINED_STRING, function () {
					assert.exists(_element);
					assert.isTrue(_element.value.equals(_elementValue));
				});

				it('be multiplied with another ZpGroupElement object', function () {
					const value = new BigInteger('176223556003478912563117221545069313999758765769681359782978834091127729142147889067304460038719516' +
						'29269607754149535740211539665348995045261657358587701662346210043656612747253073128635653862341057700248312653408740283457' +
						'80289071125634840715356038656543523573174351015744061536060638980278353555750092687859571990887232646359474282426823529365' +
						'50175121915030961234807902017236718937677215305940916228383143070650374213575095020715342570586991085678857484061883377135' +
						'87720115028620834082340229099138520783966843269531709300512050305223959708619221340031586805790727526303829519932764479276' +
						'420660407803245882129216337229');
					const element2 = _mathService.newZpGroupElement(_p, _q, value);
					const groupResult = _element.multiply(element2);

					assert.exists(groupResult);
					assert.isTrue(groupResult.value.equals(new BigInteger('3479925937595791079058166215253779710711804571585665886488360960038604917241297' +
						'08701665260784407738710570357651548065554466178771283027591456314745173473937543357798680697840267283025104854340467175443' +
						'95063240316933749517824964503453474587818564891018600565393802502524434780925086947668730209155399712963696671143009936626' +
						'79034367049865379504743903746532090597805793190953761726333772571571711836534796624222213383694592649445613110957980092758' +
						'88617478447923830855185820438729842952112821941138867053340634121267088833350281269179487083096742356370690478028429832397' +
						'5169047177718337103595301603138513792437756098010')));
				});

				it('be exponentiated with an Exponent object', function () {
					const value = new BigInteger('105699153178401195518915401453224455203745131796042384501220842020593030995244492128955094106467126' +
						'77518246732774087077365407612949713411382287231545961188659161720085145215966880365568880639826638330954959563546349431336' +
						'85881663300793778539731857379447373538585417967581255368122845936234296412374444825663785227049129936432926294327745616868' +
						'75688909015802103424446123823866899481210846806342024738405189416350013849409400612786820587056926908708731589977327051850' +
						'57241683509505884842075057053820796485397918375422045355699765507231604015240009664648666897501164834456841100119354492173' +
						'738143793809076754565709429809');
					const exponent = _mathService.newExponent(_q, value);
					const groupResult = _element.exponentiate(exponent);

					assert.exists(groupResult);
					assert.isTrue(groupResult.value.equals(new BigInteger('4851431707919104148144032366176840325558980713178470858258634042138303510085113' +
						'42277954190958139271018910829181440848436930959558488820330274210401831102017837385943106194246738119759801517063934877284' +
						'70729068278291220731421750611859395259849472853709591586826757249226947366171401157835450377500622310193840749565450926521' +
						'64343246342455179557075882874436297482194706855739748030475702582037154219176305439502884791270690743874308109172602094305' +
						'73165205775164777498008161305137192925489803089398022492883005931677667566829383896363783820465698357582243969398174847385' +
						'3330658030007815956917514768320487236434236684077')));
				});

				it('be inverted', function () {
					const groupResult = _element.invert();

					assert.exists(groupResult);
					assert.isTrue(groupResult.value.equals(new BigInteger('2696038265455559782378754885130174834873769239531880351981717786125503886057202' +
						'44886196210628040112173250399254590893675938371726135199938500117849948825217528239974520265866397652498471309862931300181' +
						'70354634822776382682558219905254606425854653980527545587896818659231514205691544478554217115755598932195979785745613955056' +
						'75184692235507580038900215686744763610681195257790146283050108524928753178490705419751756658960704501983894778487490110931' +
						'11647622698020927140606235571363901818158457995101875311127992594839914208115887573703204130065003541577672267920714110917' +
						'8220595382473109524611765840906229954707701314995')));
				});

				it(BE_SERIALIZED_DESERIALIZED_STRING, function () {
					const elementJson = _element.toJson();

					const elementFromJson = _mathService.newZpGroupElement(elementJson);

					assert.exists(elementFromJson);
					assert.isTrue(elementFromJson.equals(_element));
				});
			});

		describe(
			'create a new Exponent object that should be able to ..', function () {
				it(BE_DEFINED_STRING, function () {
					assert.exists(_exponent);
					assert.isTrue(_exponent.value.equals(_exponentValue));
				});

				it('be added to another Exponent object', function () {
					const value = new BigInteger('105699153178401195518915401453224455203745131796042384501220842020593030995244492128955094106467126' +
						'77518246732774087077365407612949713411382287231545961188659161720085145215966880365568880639826638330954959563546349431336' +
						'85881663300793778539731857379447373538585417967581255368122845936234296412374444825663785227049129936432926294327745616868' +
						'75688909015802103424446123823866899481210846806342024738405189416350013849409400612786820587056926908708731589977327051850' +
						'57241683509505884842075057053820796485397918375422045355699765507231604015240009664648666897501164834456841100119354492173' +
						'738143793809076754565709429809');
					const exponent2 = _mathService.newExponent(_q, value);

					const exponentResult = _exponent.add(exponent2);
					assert.exists(exponentResult);
					assert.isTrue(exponentResult.value.equals(new BigInteger('9767803708386994609018674734957999618293977293364027353217831927553119601068' +
						'75973173012609022644300504201448201939279494353945744535919947125845120527239359531146522995193497774570173745149073866948' +
						'79462928094310709851330112436614494131827600722543189732889834080614454300931528981810497022124445000824677033968923745154' +
						'97140061631074272142090273875744028501185507062984234571601498726946310603168350878670007509515583281158768605604358765087' +
						'70063837889096506328434603301246503271513170813313678849946062566516305748091603061757093389980287765641641653080853285914' +
						'8928739773034045877072056773250405012957363330168501')));
				});

				it('subtract another Exponent object from itself', function () {
					const value = new BigInteger('105699153178401195518915401453224455203745131796042384501220842020593030995244492128955094106467126' +
						'77518246732774087077365407612949713411382287231545961188659161720085145215966880365568880639826638330954959563546349431336' +
						'85881663300793778539731857379447373538585417967581255368122845936234296412374444825663785227049129936432926294327745616868' +
						'75688909015802103424446123823866899481210846806342024738405189416350013849409400612786820587056926908708731589977327051850' +
						'57241683509505884842075057053820796485397918375422045355699765507231604015240009664648666897501164834456841100119354492173' +
						'738143793809076754565709429809');
					const exponent2 = _mathService.newExponent(_q, value);

					const exponentResult = exponent2.subtract(_exponent);
					assert.exists(exponentResult);
					assert.isTrue(exponentResult.value.equals(new BigInteger('7762614292546378824658897934693489573044864910510459457489763972197840205785' +
						'81273728765764130395811420903632242376707906050780782188206755454462497157636875517938661225635411211371778002149149174247' +
						'11779693946838137396093088230367794724089122660927448340436445426544134122600645217313776035751399169465544016768921845308' +
						'52574476682697841001948722504555922743699624872321295316236022377843542193385263322184265079906729426591791216824461289105' +
						'83211600968063690771768069303339605770893911213680538685609700815467597318633335683564280921292633403865086340700684446263' +
						'48414270825970780202691641535582099377746698639278')));
				});

				it('be multiplied with another Exponent object', function () {
					const value = new BigInteger('105699153178401195518915401453224455203745131796042384501220842020593030995244492128955094106467126' +
						'77518246732774087077365407612949713411382287231545961188659161720085145215966880365568880639826638330954959563546349431336' +
						'85881663300793778539731857379447373538585417967581255368122845936234296412374444825663785227049129936432926294327745616868' +
						'75688909015802103424446123823866899481210846806342024738405189416350013849409400612786820587056926908708731589977327051850' +
						'57241683509505884842075057053820796485397918375422045355699765507231604015240009664648666897501164834456841100119354492173' +
						'738143793809076754565709429809');
					const exponent2 = _mathService.newExponent(_q, value);

					const exponentResult = _exponent.multiply(exponent2);
					assert.exists(exponentResult);
					expect(exponentResult.value.toString())
						.to.equal('6825741181070116566142506671668667715930882718368152921129618833608580664592126232744499319236742932558835375' +
						'78996369513600517509664154232104046478152651169840234440430946027239487677467967775963369464651756528363664352747204009947' +
						'91818974534138124068410925789068689081092566034165131071311016097550793641564357759265071104768637300861469095081386523398' +
						'21733545911331468398569477374835027440704168707673103720258333624116935508711425541865845525659810391235054928138021300351' +
						'03680667717466448747339085670631656547755782593013655004878943207942800285876413436881081142077244807596275855311983084014' +
						'5021767564663309628');
				});

				it('be multiplied with Exponent objects encapsulating large values',
					function () {
						const exponentResult = _exponent1Large.multiply(_exponent2Large);
						assert.exists(exponentResult);
					});

				it('be negated', function () {
					const exponentResult = _exponent.negate();

					assert.exists(exponentResult);
					assert.isTrue(exponentResult.value.equals(new BigInteger('8021116094531249428728654103644459020805358862402110969042522745061834984556' +
						'89481165383320420269672476232250754694282421868155504354211911028780340688795063850254855193280989134663831429149087968843' +
						'00866675411527844620384757297155852460263724631947550044640244611823038246052833027831264075167924436578893445537811678386' +
						'71892013122031840265972950151575517091569375493981521183466223577343235993054896402716274918693576589025100764543469276031' +
						'70234780106767641900711208671044473169710366923917032297024772253212364564439669147936297704212362353248232136088968305685' +
						'528101327085308615101681370543404063797202379261308')));
				});

				it(BE_SERIALIZED_DESERIALIZED_STRING, function () {
					const exponentJson = _exponent.toJson();

					const exponentFromJson = _mathService.newExponent(exponentJson);

					assert.exists(exponentFromJson);
					assert.isTrue(exponentFromJson.equals(_exponent));
				});
			});

		it('create a new quadratic residue Zp subgroup', function () {
			const group = _mathService.newQuadraticResidueGroup(_p, _g);
			assert.exists(group);
		});

		it('check if a group matches the configured policy',
			function () {
				expect(function () {
					const policy = cryptoPolicy.newInstance();
					policy.mathematical.groups.type =
						cryptoPolicy.options.mathematical.groups.type.ZP_2048_224;

					const mathServiceQR2048 = mathematical.newService({policy: policy});

					mathServiceQR2048.checkGroupMatchesPolicy(_zp224group);
				}).to.not.throw();

				expect(function () {
					const policy = cryptoPolicy.newInstance();
					policy.mathematical.groups.type =
						cryptoPolicy.options.mathematical.groups.type.ZP_2048_256;

					const mathServiceQR2048 = mathematical.newService({policy: policy});

					mathServiceQR2048.checkGroupMatchesPolicy(_anotherGroup);
				}).to.not.throw();

				expect(function () {
					const policy = cryptoPolicy.newInstance();
					policy.mathematical.groups.type =
						cryptoPolicy.options.mathematical.groups.type.QR_2048;

					const mathServiceQR2048 = mathematical.newService(policy);

					mathServiceQR2048.checkGroupMatchesPolicy(_qrGroup);
				}).to.not.throw();

				expect(function () {
					const policy = cryptoPolicy.newInstance();
					policy.mathematical.groups.type =
						cryptoPolicy.options.mathematical.groups.type.QR_2048;

					const mathServiceQR2048 = mathematical.newService(policy);

					mathServiceQR2048.checkGroupArrayMatchesPolicy(goodElements);
				}).to.not.throw();

				expect(function () {
					const policy = cryptoPolicy.newInstance();
					policy.mathematical.groups.type =
						cryptoPolicy.options.mathematical.groups.type.QR_3072;

					const mathServiceQR3072 = mathematical.newService(policy);

					mathServiceQR3072.checkGroupArrayMatchesPolicy(goodElements);
				}).to.not.throw();
			});

		describe(
			'create a new MathematicalRandomGenerator object that should be able to ..',
			function () {

				it('generate a random Exponent', function () {
					const randomExponent = _mathRandomGenerator.nextExponent(_qrGroup);
					assert.exists(randomExponent);
				});

				it('generate a short random Exponent', function () {
					let randomExponent = _mathRandomGenerator.nextExponent(
						_qrGroupLarge, {useShortExponent: true});
					assert.exists(randomExponent);

					randomExponent = _mathRandomGenerator.nextExponent(
						_qrGroup, {useShortExponent: true});
					assert.exists(randomExponent);
				});
			});
	});
});
